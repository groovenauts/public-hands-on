Rubyの主要なクラスとリテラル
============================

# リテラルとは

『コンピュータプログラミングにおいてリテラルは、ソースコード内に値を
直接表記したものをいう。数値、文字列、関数などさまざまな型のものが
存在し、それぞれの表記方法も言語によって異なる。

レキシカルな識別が容易であることが多いので、シンタックスハイライト
はたいてい色分けされる。

例
下のコードで、7や"hello"がリテラルである。

    int x = 7;
    string s = "hello";


[リテラル - Wikipedia](http://ja.wikipedia.org/wiki/リテラル) より引用


## Rubyのリテラル

公式リファレンスにも [リテラル](http://doc.ruby-lang.org/ja/1.9.3/doc/spec=2fliteral.html) というページで説明されています。

ここでは主にこのページから一部を抜粋して説明します。


## 数値

### リテラル

    123    # 整数
    -123   # 符号付き整数
    123.45 # 浮動小数点数
    1.2e-3 # 浮動小数点数
    0xffff # 16進数
    0b1011 # 2進数
    0o377  # 8進数
    0377   # 8進数

### 演算

     1 + 2
     1 - 2
     2 * 3
     10 / 3
     10.0 / 3
     10 % 3
     10.divmod(3)
     
### 繰り返し

     10.times{ puts "foo" }
     10.times{|i| puts "foo#{i}" }
     3.step(5){|n| puts n}

### 文字列への変換

     10.to_s

n進数に変換することもできます。

     20.to_s(16)
     40.to_s(36)

ちなみに37進数以上は変換出来ません。


### 特徴

rubyの整数にはメモリサイズ以外の制限はありません。例えばこんな計算もできます。

    a = 123456789123456789123456789123456789
    b = 987654321987654321987654321987654321
    a + b

to_iで文字列を整数に変換できるので、200桁の整数同士を足してみます。

    ("1" * 200).to_i + ("2" * 200).to_i





## 文字列

### 基本的なリテラル

    "this is a string expression\n"
    'this is a string expression\n'

### 足し算と掛け算できます

    "a" + "b"
    "a" * 100

### バックスラッシュ記法

\n や \t がよく使われると思います。

    puts "foo\n\n\tbar"

シングルクォーテーション中ではバックスラッシュ記法は無効です。

    puts 'foo\n\n\tbar'


### 式展開

文字列中にrubyの式を書くことができます。

     h10 = "hoge" * 10
     "foo#{h10}bar"

単なる変数を書けるのではなく複雑な式を書くこともできます

     "foo#{ t = Time.now; t.utc.to_s }bar"

シングルクォーテーション中では式展開は行われません。

     'foo#{ t = Time.now; t.utc.to_s }bar'


### 一部を抽出できます

    s = "0123456789"

n番目と言ったら0から数えます

    s[5]     # 5番目の文字
    s[2,3]   # 2番目から３つ
    s[2..3]  # 2番目から3番目まで
    s[2..-1] # 2番目から-1番目（最後から数えて1番目）まで

代入もできちゃいます

    s[5] = "A"
    s # 1

    s[2,3] = "BCD"
    s # 2

    s[2..3] = "EFG"
    s # 3

    s[2..-1] = "XYZ"
    s # 4

置換ですね。

でも置換については後述のsub, gsubとかはもっと強力です。


### 他にも機能がたくさん

    s.upcse
    s.downcase
    s.include?("A")


## シンボル

Rubyの内部で使われるメソッド名、変数名などの色々な名前は、文字列よりも効率が良く、速度も早いので整数で管理されています。
この整数をRubyのコード上で表現したものがシンボルです。

    :foo

ハッシュのキーによく使用されます。


### 文字列との変換

    "foo".to_sym
    :foo.to_s

## 配列

### 一般的なリテラル

    [1,2,3]

どんな型のオブジェクトでも追加できます。

    ["a", 5, Time.now]

### 繰り返し

    [1,1,2,3,5,8,13,21].each{|n| puts n}

あるいは

    [1,1,2,3,5,8,13,21].each do |n|
      puts n
    end

### 一部を抽出

    a = [1,1,2,3,5,8,13,21]

配列でもn番目と言ったら0から数えます

    a[5]     # 5番目を取得
    a[2,3]   # 2番目から３つを取得
    a[2..3]  # 2番目から3番目まで取得
    a[2..-1] # 2番目から-1番目まで取得

文字列と同じ感じの操作ですよね？
きっと代入もできますよ

    a.first
    a.last


### 他の使い方

    [10, 3, 30, 15].sort # 並び替え
    ["a", "b", "c"].join(", ") # 要素を結合
    [1,2,3,1,2,5].uniq # 重複したものを除去 


詳しくは[こちら](http://doc.ruby-lang.org/ja/2.0.0/class/Array.html)をご覧ください



### ハッシュ

連想配列（キーと値を持つデータ構造）を表現します。

### 一般的なリテラル

    {1 => 100, 2 => 300, 3 => 500}
    {"foo" => 0, "bar" => 3, "baz" => 6}
    {:foo => 0, :bar => 3, :baz => 6}

キーがシンボルの場合に限って、こんなJSONっぽい書き方もできます。

    {foo: 0, bar: 3, baz: 6}
    # => {:foo=>0, :bar=>3, :baz=>6}

### 一般的な使い方

    m = {:foo => 1, :bar => 2}
    m[:foo]
    m[:foo] = 100
    m[:baz] = 200

キーや値はシンボルや整数でなくてもOKです。

    m["hoge"] = "HOGE"
    m[:now] = Time.now
    m[100] = "handred"

キーや値だけを取得することもできます。

    m.keys # キーだけ取得
    m.values # 値だけ取得

### 繰り返し

    m.each do |key, value|
      puts "#{key} : #{value}"
    end

### その他

    {foo: 1, bar: 2, baz: 3}.invert # キーと値を入れ替え

詳しくは [こちら](http://doc.ruby-lang.org/ja/2.0.0/class/Hash.html) をご覧ください

値が重複した場合のinvertが気になる方は [こちら](http://doc.ruby-lang.org/ja/2.0.0/class/Hash.html#I_INVERT) もどうぞ


## 範囲オブジェクト

### リテラル

実は既に登場している範囲オブジェクト

    2..5
    2...5

後者は5を含みません。


### 使い方

    r = (1..5)
    r.each{|i| puts i}
    r.to_a
    r.first
    r.last

### 整数以外もOK

例えば文字列

    r = "A".."Z"
    r.to_a

    r = "AA".."ZZ"
    r.to_a


## 正規表現

テキストを調べたり操作するための機能

### 主なリテラル

    /正規表現/

### 使い方

よく使われる表現

    ^  # 行頭
    $  # 行末
    .  # 改行を除く任意の 1 文字
    \d # 数字
    \w # 英数字
    \s # 空白文字

    * # 0個以上の繰り返し
    + # 1つ以上の繰り返し
    ? # 0個か1個

    |  # あるいは

より詳しい説明は[こちら](http://doc.ruby-lang.org/ja/1.9.3/doc/spec=2fregexp.html)


例「先頭でbaで始まりooで終わる文字列」

    re = /^ba.+oo$/

    re =~ "barfoo" #=>0
    re =~ "barfoobaz" #=>nil

例「fooかbarを含む文字列」

    re = /foo|bar/

例「fooあるいはbar」

    re = /^foo$|^bar$/

### 置換

subはマッチした最初の文字列を置換、gsubは全てのマッチした文字列を置換します。

    "foobarbaz".sub(/foo|bar/, "hoge")
    "foobarbaz".gsub(/foo|bar/, "hoge")
