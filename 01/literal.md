Rubyの主要なクラスとリテラル
============================

# リテラルとは

コンピュータプログラミングにおいてリテラルは、ソースコード内に値を
直接表記したものをいう。数値、文字列、関数などさまざまな型のものが
存在し、それぞれの表記方法も言語によって異なる。即値ともいう。
    
レキシカルな識別が容易であることが多いので、シンタックスハイライト
はたいてい色分けされる。
    
例
下のコードで、7や"hello"がリテラルである。

    int x = 7;
    string s = "hello";

[リテラル - Wikipedia](http://ja.wikipedia.org/wiki/リテラル)


## Rubyのリテラル

公式リファレンスにも [リテラル](http://doc.ruby-lang.org/ja/1.9.3/doc/spec=2fliteral.html) というページで書いてあります。

ここでは一部を抜粋して説明します。


## 数値

### リテラル

   123    # 整数
   -123   # 符号付き整数
   123.45 # 浮動小数点数
   1.2e-3 # 浮動小数点数
   0xffff # 16進数
   0b1011 # 2進数
   0o377  # 8進数
   0377   # 8進数

### 演算

     1 + 2
     1 - 2
     2 * 3
     10 / 3
     10.0 / 3
     10 % 3
     10.divmod(3)
     
### 繰り返し

     10.times{ puts "foo" }
     10.times{|i| puts "foo#{i}" }
     3.step(5){|n| puts n}

### 文字列への変換

     10.to_s

n進数に変換することもできます

     20.to_s(16)
     40.to_s(36)

### 特徴

rubyの整数にはメモリサイズ以外の制限はありません。例えばこんな計算もできます

    a = 123456789123456789123456789123456789
    b = 987654321987654321987654321987654321
    a + b

to_iで文字列を整数に変換できるので、200桁の整数同士を足してみます。

    ("1" * 200).to_i + ("2" * 200).to_i





## 文字列

### 基本的なリテラル

    "this is a string expression\n"
    'this is a string expression\n'

### 足し算と掛け算できます

    "a" + "b"
    "a" * 100

### バックスラッシュ記法

\n や \t がよく使われると思います。

    puts "foo\n\n\tbar"

シングルクォーテーション中ではバックスラッシュ記法は無効です。

    puts 'foo\n\n\tbar'


### 式展開

文字列中にrubyの式を書くことができます。

     h10 = "hoge" * 10
     "foo#{h10}bar"

単なる変数を書けるのではなく複雑な式を書くこともできます

     "foo#{ t = Time.now; t.utc.to_s }bar"

シングルクォーテーション中では式展開は行われません。

     'foo#{ t = Time.now; t.utc.to_s }bar'


### 一部を抽出できます

* 0オリジンで5番目の文字

    "0123456789"[5]

* 0オリジンで2番目から３つ
* 0オリジンで2番目から3番目まで
* 0オリジンで2番目から-1番目（最後から数えて1番目）まで

    "0123456789"[2,3]
    "0123456789"[2..3]
    "0123456789"[2..-1]

### 他にも機能がたくさん





## シンボル

Rubyの内部で使われるメソッド名、変数名などの色々な名前は、文字列よりも効率が良く、速度も早いので整数で管理されています。
この整数をRubyのコード上で表現したものがシンボルです。

    :foo


ハッシュのキーによく使用されます。


### 文字列との変換

    "foo".to_sym
    :foo.to_s

## 配列

### 一般的なリテラル

    [1,2,3]

どんな型のオブジェクトでも追加できます。

    ["a", 5, Time.now]

### 繰り返し

    [1,1,2,3,5,8,13,21].each{|n| puts n}

### 一部を抽出

    a = [1,1,2,3,5,8,13,21]

0オリジンで5番目を取得

    a[5]

0オリジンで2番目から３つを取得

    a[2,3]

0オリジンで2番目から4番目まで取得

    a[2..4]

0オリジンで2番目から-1番目まで取得

    a[2..-1]


文字列と同じ感じの操作でしょ？




### ハッシュ式

連想配列（キーと値を持つデータ構造）を表現します。

    {1 => 100, 2 => 300, 3 => 500}
    {"foo" => 0, "bar" => 3, "baz" => 6}
    {:foo => 0, :bar => 3, :baz => 6}

こんな書き方もできます。

    {foo: 0, bar: 3, baz: 6}
    # => {:foo=>0, :bar=>3, :baz=>6}

### 一般的な使い方



## 範囲オブジェクト

    

## 正規表現リテラル



## コマンド出力

コマンドを実行してその結果を文字列として取得

    s = `ls -la`
    puts s

式展開やバックスラッシュ記法を使うこともできます。

    cmd = (RUBY_PLATFORM =~ /mswin(?!ce)|mingw|cygwin|bccwin/) ? 'dir' : 'ls -la'
    puts `echo "#{cmd}" && #{cmd}`

   
## %記法
